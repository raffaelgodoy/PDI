# -*- coding: utf-8 -*-
"""
Created on Sat Sep 21 16:01:41 2024

@author: rdgod
"""
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D  # Importa para gráficos 3D
import cv2  # Para desenhar quadrados na imagem

# Definir o caminho da imagem e do template no diretório local
pasta = r"C:\Users\rdgod\OneDrive\Desktop\PDI - Centeno\Imagens"
imagem_nome = "correlacao.jpg"  # Nome da imagem
template_nome = "template2.jpg"  # Nome do template

# Função para transformar matriz em vetor
def mat2vec(M):
    return M.flatten()

# Ler imagem de entrada e recuperar dimensões
X1 = plt.imread(f'{pasta}\\{imagem_nome}')
if X1.ndim == 3:  # Imagem colorida (3 canais)
    X1 = np.mean(X1, axis=2)  # Converte para escala de cinza

nl, nc = X1.shape
X = np.array(X1, dtype=float)  # transforma em float
Y = np.zeros((nl, nc), dtype=float)  # replica para gerar saída
Y = np.uint8(Y)

# Ler template
T1 = plt.imread(f'{pasta}\\{template_nome}')
if T1.ndim == 3:  # Imagem colorida (3 canais)
    T1 = np.mean(T1, axis=2)  # Converte para escala de cinza

tl, tc = T1.shape
T = np.array(T1, dtype=float)
print('Image size: ', nl, nc, " Template size: ", tl, tc)

dim = tl  # tamanho do template, DEVE ser um quadrado!
lado = (dim - 1) // 2  # número de vizinhos antes ou depois do central
TT = mat2vec(T)  # transforma matriz template a vetor

# Criar uma imagem RGB para desenhar as marcações
imagem_marked = np.zeros((nl, nc, 3), dtype=np.uint8)  # Inicializa a imagem RGB
imagem_marked[..., 0] = X1  # Copia a imagem original para o canal vermelho
imagem_marked[..., 1] = X1  # Copia para o canal verde
imagem_marked[..., 2] = X1  # Copia para o canal azul

# Limite para considerar uma correlação como significativa
limite_correlaçao = 0.75  # Ajuste esse valor conforme necessário

# Lista para armazenar coordenadas de linhas e colunas marcadas
coordenadas_marcadas = []

for L in range(lado, nl - lado):  # varrer em linhas
    for C in range(lado, nc - lado):  # varrer em colunas
        p = L - lado  # posição inicial, canto superior esquerdo do recorte
        q = C - lado
        R = X[p:p + tl, q:q + tc]
        
        if R.shape != (tl, tc):
            continue  # Se o recorte não tiver as dimensões esperadas, pula a iteração

        RR = mat2vec(R)  # transforma região a vetor
        rm = np.corrcoef(RR, TT)  # matriz de correlação
        r = rm[0, 1]  # correlação
        print(f"Correlação em ({L}, {C}): {r}")  # Print de depuração
        if r < 0:  # não nos interessam correlações negativas
            r = 0
        rp = r * 255  # transformar em uint8 para salvar
        v = np.uint8(np.round(rp))  # arredonda e muda para uint8
        Y[L, C] = v  # salva na posição do central
        
        # Marcar com um quadrado se a correlação for significativa
        if r > limite_correlaçao:
            # Calcular as coordenadas do quadrado
            top_left = (C - lado, L - lado)  # Canto superior esquerdo
            bottom_right = (C + lado, L + lado)  # Canto inferior direito
            cv2.rectangle(imagem_marked, top_left, bottom_right, (180, 0, 0), 2)  # Vermelho
            
            # Armazenar as coordenadas da região marcada
            coordenadas_marcadas.append((L, C))

# Salvar a matriz de correlações em escala de cinza
plt.imsave(f'{pasta}\\Matriz.png', Y, cmap='gray')

# Mostrar a imagem com as marcações
plt.imshow(imagem_marked)
plt.title("Marcação de Regiões Correlacionadas")
plt.axis('off')  # Desativar eixos
plt.show()

# Opcional: Salvar a imagem com as marcações
plt.imsave(f'{pasta}\\imagem_marked.png', imagem_marked)

# Exibir as coordenadas marcadas
if coordenadas_marcadas:
    print("\nCoordenadas das regiões marcadas (linhas, colunas):")
    for coords in coordenadas_marcadas:
        print(coords)
else:
    print("Nenhuma região foi marcada.")

